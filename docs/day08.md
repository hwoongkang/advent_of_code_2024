# Day 08

전 그냥 구현으로 풀었습니다.

## Part 1

선형 보간만 하면 됩니다.

```
......#.       ........*
....*...       ......*..
..*..... => 2  ....#.... => 1
#.......       .........
```

그런데 다른 선형 보간 결과와 겹쳤을 때 한 번만 써야 하므로, visited 배열을 쓰든, HashSet을 쓰든 하면 됩니다.
저는 귀찮아서 HashSet 썼습니다.

각 유형의 안테나 수를 n이라 했을 때, nC2 만큼 선형보간 하면 되므로 O(n^2)입니다.

지도의 크기를 r\*r이라 했을 때 worst case는 n~=O(r^2)겠지만, 그렇게 빡빡하지 않아서 대충 n~=r 이라 O(n^2)도 충분합니다.

## Part 2

선형 보간만 하는게 아니라, 직선 상의 정수점을 모두 고려해주어야 합니다.

이것도 n이 좀 컸으면 O(r \* n^2)으로 풀기 부담스러웠겠지만, n이 별로 크지 않아 n^2 개의 페어링에 대해 직선 상의 모든 정수점 카운팅(~지도의 크기 r)해주어 풀었습니다.

이때 주의해야 할게 두 안테나가 예를들어 (+2, +2)만큼 떨어져 있으면 중점도 세어야 하므로, (dx, dy) 벡터를 약분해서 사용해야 합니다.

또한 각 안테나 자체도 카운팅해야 한다는 것을 놓치지 않아야 합니다.

```
..#............
....*..........
......#........ => 5
........*......
..........#....
```
